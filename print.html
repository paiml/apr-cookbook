<!DOCTYPE HTML>
<html lang="en" class="rust" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>APR Cookbook - Idiomatic Rust Patterns for ML Model Deployment</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Production recipes for bundling, converting, and deploying ML models using the APR format with Toyota Way quality principles">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('rust')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="getting-started/installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="getting-started/quick-start.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="getting-started/structure.html"><strong aria-hidden="true">3.</strong> Project Structure</a></li><li class="chapter-item expanded affix "><li class="part-title">Core Concepts</li><li class="chapter-item expanded "><a href="concepts/apr-format.html"><strong aria-hidden="true">4.</strong> The APR Format</a></li><li class="chapter-item expanded "><a href="concepts/bundling.html"><strong aria-hidden="true">5.</strong> Model Bundling</a></li><li class="chapter-item expanded "><a href="concepts/conversion.html"><strong aria-hidden="true">6.</strong> Format Conversion</a></li><li class="chapter-item expanded "><a href="concepts/zero-copy.html"><strong aria-hidden="true">7.</strong> Zero-Copy Loading</a></li><li class="chapter-item expanded affix "><li class="part-title">Recipes</li><li class="chapter-item expanded "><a href="recipes/bundle-static.html"><strong aria-hidden="true">8.</strong> Bundle a Static Model</a></li><li class="chapter-item expanded "><a href="recipes/bundle-quantized.html"><strong aria-hidden="true">9.</strong> Bundle with Quantization</a></li><li class="chapter-item expanded "><a href="recipes/encrypt-model.html"><strong aria-hidden="true">10.</strong> Encrypt a Model</a></li><li class="chapter-item expanded "><a href="recipes/convert-safetensors.html"><strong aria-hidden="true">11.</strong> Convert from SafeTensors</a></li><li class="chapter-item expanded "><a href="recipes/convert-gguf.html"><strong aria-hidden="true">12.</strong> Convert from GGUF</a></li><li class="chapter-item expanded "><a href="recipes/export-gguf.html"><strong aria-hidden="true">13.</strong> Export to GGUF</a></li><li class="chapter-item expanded "><a href="recipes/simd-acceleration.html"><strong aria-hidden="true">14.</strong> SIMD Acceleration</a></li><li class="chapter-item expanded affix "><li class="part-title">CLI Tools</li><li class="chapter-item expanded "><a href="cli/apr-info.html"><strong aria-hidden="true">15.</strong> apr-info</a></li><li class="chapter-item expanded "><a href="cli/apr-bench.html"><strong aria-hidden="true">16.</strong> apr-bench</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced Topics</li><li class="chapter-item expanded "><a href="advanced/wasm.html"><strong aria-hidden="true">17.</strong> WASM Deployment</a></li><li class="chapter-item expanded "><a href="advanced/custom-models.html"><strong aria-hidden="true">18.</strong> Custom Model Types</a></li><li class="chapter-item expanded "><a href="advanced/performance.html"><strong aria-hidden="true">19.</strong> Performance Optimization</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/api.html"><strong aria-hidden="true">20.</strong> API Documentation</a></li><li class="chapter-item expanded "><a href="reference/errors.html"><strong aria-hidden="true">21.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="reference/features.html"><strong aria-hidden="true">22.</strong> Feature Flags</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">APR Cookbook - Idiomatic Rust Patterns for ML Model Deployment</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/paiml/apr-cookbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>APR Cookbook</strong> provides idiomatic Rust patterns for deploying machine learning models using the APR format. Built on Toyota Way principles, it emphasizes zero-defect quality and production readiness.</p>
<h2 id="what-is-apr"><a class="header" href="#what-is-apr">What is APR?</a></h2>
<p>APR (Aprender Portable Runtime) is a native Rust ML model format designed for:</p>
<ul>
<li><strong>Zero-copy loading</strong> - Models load directly from memory without parsing overhead</li>
<li><strong>Compile-time embedding</strong> - Use <code>include_bytes!()</code> to bundle models in your binary</li>
<li><strong>WASM compatibility</strong> - Deploy the same model to browser and server</li>
<li><strong>Security</strong> - Optional AES-256-GCM encryption with Argon2id key derivation</li>
</ul>
<h2 id="why-apr-cookbook"><a class="header" href="#why-apr-cookbook">Why APR Cookbook?</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Challenge</th><th>Solution</th></tr></thead><tbody>
<tr><td>Large model files</td><td>Quantization (Q4, Q8) reduces size 4-8x</td></tr>
<tr><td>Slow cold starts</td><td>Zero-copy loading, no deserialization</td></tr>
<tr><td>Model theft</td><td>AES-256-GCM encryption at rest</td></tr>
<tr><td>Format lock-in</td><td>Convert from/to SafeTensors, GGUF</td></tr>
<tr><td>Platform limits</td><td>WASM-ready, no native dependencies</td></tr>
</tbody></table>
</div>
<h2 id="the-sovereign-stack"><a class="header" href="#the-sovereign-stack">The Sovereign Stack</a></h2>
<p>APR Cookbook integrates with the Sovereign AI Stack:</p>
<pre><code>┌─────────────────────────────────────────┐
│           Your Application              │
├─────────────────────────────────────────┤
│  apr-cookbook  │  Recipes &amp; patterns    │
├────────────────┼────────────────────────┤
│    aprender    │  ML algorithms         │
├────────────────┼────────────────────────┤
│     trueno     │  SIMD compute          │
├────────────────┼────────────────────────┤
│    entrenar    │  Training &amp; optim      │
└─────────────────────────────────────────┘
</code></pre>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<pre><code class="language-rust">use apr_cookbook::bundle::{BundledModel, ModelBundle};

// Embed model at compile time
const MODEL: &amp;[u8] = include_bytes!(&quot;model.apr&quot;);

fn main() -&gt; apr_cookbook::Result&lt;()&gt; {
    // Zero-copy load
    let model = BundledModel::from_bytes(MODEL)?;

    println!(&quot;Loaded: {} ({} bytes)&quot;, model.name(), model.size());
    Ok(())
}</code></pre>
<h2 id="toyota-way-principles"><a class="header" href="#toyota-way-principles">Toyota Way Principles</a></h2>
<p>This cookbook follows Toyota Way quality principles:</p>
<ol>
<li><strong>Jidoka</strong> - Build quality in, don't inspect it in</li>
<li><strong>Genchi Genbutsu</strong> - Go see for yourself</li>
<li><strong>Kaizen</strong> - Continuous improvement</li>
<li><strong>Muda elimination</strong> - Remove waste (unnecessary copies, allocations)</li>
</ol>
<p>Every recipe includes tests, benchmarks, and quality metrics.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="./getting-started/installation.html">Installation</a> - Add apr-cookbook to your project</li>
<li><a href="./getting-started/quick-start.html">Quick Start</a> - Bundle your first model</li>
<li><a href="./recipes/bundle-static.html">Recipes</a> - Production-ready patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>Rust 1.75 or later</li>
<li>Cargo (included with Rust)</li>
</ul>
<h2 id="add-to-cargotoml"><a class="header" href="#add-to-cargotoml">Add to Cargo.toml</a></h2>
<pre><code class="language-toml">[dependencies]
apr-cookbook = &quot;0.1&quot;
</code></pre>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>Enable optional features as needed:</p>
<pre><code class="language-toml">[dependencies]
apr-cookbook = { version = &quot;0.1&quot;, features = [&quot;encryption&quot;] }
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>default</code></td><td>Core bundling and conversion</td></tr>
<tr><td><code>encryption</code></td><td>AES-256-GCM model encryption</td></tr>
<tr><td><code>training</code></td><td>Integration with entrenar</td></tr>
<tr><td><code>full</code></td><td>All features enabled</td></tr>
</tbody></table>
</div>
<h2 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h2>
<pre><code class="language-rust">use apr_cookbook::bundle::ModelBundle;

fn main() {
    let bundle = ModelBundle::new()
        .with_name(&quot;test&quot;)
        .build();

    println!(&quot;APR magic: {:?}&quot;, &amp;bundle[0..4]);
    // Output: APR magic: [65, 80, 82, 78] (APRN)
}</code></pre>
<h2 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h2>
<p>For contributors:</p>
<pre><code class="language-bash">git clone https://github.com/paiml/apr-cookbook
cd apr-cookbook
make test-fast    # Run tests
make lint         # Check code quality
make coverage     # Generate coverage report
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Bundle and load your first APR model in 5 minutes.</p>
<h2 id="step-1-create-a-model-bundle"><a class="header" href="#step-1-create-a-model-bundle">Step 1: Create a Model Bundle</a></h2>
<pre><code class="language-rust">use apr_cookbook::bundle::ModelBundle;

fn main() {
    // Your model weights (from training or file)
    let weights: Vec&lt;u8&gt; = vec![/* your model bytes */];

    // Create APR bundle
    let bundle = ModelBundle::new()
        .with_name(&quot;my-classifier&quot;)
        .with_description(&quot;Sentiment classifier v1.0&quot;)
        .with_compression(true)
        .with_payload(weights)
        .build();

    // Save to file
    std::fs::write(&quot;model.apr&quot;, &amp;bundle).unwrap();
    println!(&quot;Saved: {} bytes&quot;, bundle.len());
}</code></pre>
<h2 id="step-2-load-at-runtime"><a class="header" href="#step-2-load-at-runtime">Step 2: Load at Runtime</a></h2>
<pre><code class="language-rust">use apr_cookbook::bundle::BundledModel;

fn main() -&gt; apr_cookbook::Result&lt;()&gt; {
    // Load from file
    let bytes = std::fs::read(&quot;model.apr&quot;)?;
    let model = BundledModel::from_bytes(&amp;bytes)?;

    println!(&quot;Name: {}&quot;, model.name());
    println!(&quot;Size: {} bytes&quot;, model.size());
    println!(&quot;Compressed: {}&quot;, model.is_compressed());

    Ok(())
}</code></pre>
<h2 id="step-3-embed-at-compile-time"><a class="header" href="#step-3-embed-at-compile-time">Step 3: Embed at Compile Time</a></h2>
<p>For production, embed the model directly in your binary:</p>
<pre><code class="language-rust">use apr_cookbook::bundle::BundledModel;

// Embed at compile time - zero runtime file I/O
const MODEL_BYTES: &amp;[u8] = include_bytes!(&quot;../models/classifier.apr&quot;);

fn load_model() -&gt; apr_cookbook::Result&lt;BundledModel&lt;'static&gt;&gt; {
    BundledModel::from_bytes(MODEL_BYTES)
}</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<ul>
<li><a href="getting-started/../recipes/bundle-quantized.html">Bundle with Quantization</a> - Reduce model size</li>
<li><a href="getting-started/../recipes/encrypt-model.html">Encrypt a Model</a> - Protect proprietary models</li>
<li><a href="getting-started/../recipes/convert-safetensors.html">Convert from SafeTensors</a> - Import existing models</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<h2 id="library-organization"><a class="header" href="#library-organization">Library Organization</a></h2>
<pre><code>apr-cookbook/
├── src/
│   ├── lib.rs                 # Public API exports
│   ├── bundle.rs              # Model bundling (ModelBundle, BundledModel)
│   ├── convert.rs             # Format conversion (AprConverter)
│   ├── aprender_integration.rs # aprender format integration
│   └── error.rs               # Error types
├── examples/
│   ├── bundling/              # Bundling recipes
│   │   ├── bundle_static_model.rs
│   │   ├── bundle_quantized_model.rs
│   │   └── bundle_encrypted_model.rs
│   ├── conversion/            # Format conversion
│   │   ├── convert_safetensors_to_apr.rs
│   │   ├── convert_apr_to_gguf.rs
│   │   └── convert_gguf_to_apr.rs
│   ├── acceleration/          # Performance
│   │   └── simd_matrix_operations.rs
│   └── cli/                   # Command-line tools
│       ├── apr_info.rs
│       └── apr_bench.rs
└── tests/
    ├── proptest_bundle.rs     # Property tests for bundling
    ├── proptest_convert.rs    # Property tests for conversion
    └── proptest_aprender.rs   # Property tests for integration
</code></pre>
<h2 id="module-overview"><a class="header" href="#module-overview">Module Overview</a></h2>
<h3 id="bundle---model-bundling"><a class="header" href="#bundle---model-bundling"><code>bundle</code> - Model Bundling</a></h3>
<p>Core types for creating and loading APR bundles:</p>
<ul>
<li><code>ModelBundle</code> - Builder for creating APR files</li>
<li><code>BundledModel</code> - Zero-copy model loader</li>
</ul>
<h3 id="convert---format-conversion"><a class="header" href="#convert---format-conversion"><code>convert</code> - Format Conversion</a></h3>
<p>Convert between formats:</p>
<ul>
<li><code>AprConverter</code> - Multi-format converter</li>
<li><code>TensorData</code> - Tensor representation</li>
<li><code>ConversionFormat</code> - Supported formats (APR, SafeTensors, GGUF)</li>
</ul>
<h3 id="aprender_integration---format-integration"><a class="header" href="#aprender_integration---format-integration"><code>aprender_integration</code> - Format Integration</a></h3>
<p>Direct integration with aprender's format module:</p>
<ul>
<li><code>save_model()</code> / <code>load_model()</code> - File-based I/O</li>
<li><code>AprModelInfo</code> - Model metadata inspection</li>
</ul>
<h3 id="error---error-handling"><a class="header" href="#error---error-handling"><code>error</code> - Error Handling</a></h3>
<p>Comprehensive error types:</p>
<ul>
<li><code>CookbookError</code> - Main error enum</li>
<li><code>Result&lt;T&gt;</code> - Convenience type alias</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-apr-format"><a class="header" href="#the-apr-format">The APR Format</a></h1>
<p>APR (Aprender Portable Runtime) is a binary format optimized for ML model deployment.</p>
<h2 id="design-goals"><a class="header" href="#design-goals">Design Goals</a></h2>
<ol>
<li><strong>Zero-copy loading</strong> - No parsing, direct memory access</li>
<li><strong>Compile-time embedding</strong> - Works with <code>include_bytes!()</code></li>
<li><strong>Cross-platform</strong> - Native, WASM, embedded</li>
<li><strong>Security</strong> - Optional encryption and signing</li>
</ol>
<h2 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h2>
<pre><code>┌────────────────────────────────────────┐
│  Magic (4 bytes): &quot;APRN&quot;               │
├────────────────────────────────────────┤
│  Version (2 bytes): major.minor       │
├────────────────────────────────────────┤
│  Flags (2 bytes): compression, etc.   │
├────────────────────────────────────────┤
│  Header length (4 bytes)              │
├────────────────────────────────────────┤
│  Payload length (8 bytes)             │
├────────────────────────────────────────┤
│  Metadata (variable)                  │
│  - Name (null-terminated string)      │
│  - Description (optional)             │
│  - Custom fields                      │
├────────────────────────────────────────┤
│  Payload (variable)                   │
│  - Tensor data                        │
│  - Model weights                      │
│  - Optionally compressed (zstd)       │
└────────────────────────────────────────┘
</code></pre>
<h2 id="flags"><a class="header" href="#flags">Flags</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Bit</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>0</td><td>Compressed</td><td>Payload is zstd compressed</td></tr>
<tr><td>1</td><td>Encrypted</td><td>Payload is AES-256-GCM encrypted</td></tr>
<tr><td>2</td><td>Signed</td><td>Ed25519 signature present</td></tr>
<tr><td>3-15</td><td>Reserved</td><td>Future use</td></tr>
</tbody></table>
</div>
<h2 id="version-history"><a class="header" href="#version-history">Version History</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Version</th><th>Features</th></tr></thead><tbody>
<tr><td>1.0</td><td>Initial release, basic bundling</td></tr>
<tr><td>1.1</td><td>Compression support (zstd)</td></tr>
<tr><td>1.2</td><td>Encryption (AES-256-GCM)</td></tr>
</tbody></table>
</div>
<h2 id="comparison-with-other-formats"><a class="header" href="#comparison-with-other-formats">Comparison with Other Formats</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>APR</th><th>SafeTensors</th><th>GGUF</th><th>ONNX</th></tr></thead><tbody>
<tr><td>Zero-copy</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr>
<tr><td>Rust-native</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>WASM support</td><td>✅</td><td>✅</td><td>❌</td><td>❌</td></tr>
<tr><td>Encryption</td><td>✅</td><td>❌</td><td>❌</td><td>❌</td></tr>
<tr><td>Quantization</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="model-bundling"><a class="header" href="#model-bundling">Model Bundling</a></h1>
<p>Bundling converts model weights into the APR format for deployment.</p>
<h2 id="the-modelbundle-builder"><a class="header" href="#the-modelbundle-builder">The ModelBundle Builder</a></h2>
<pre><code class="language-rust">use apr_cookbook::bundle::ModelBundle;

let bundle = ModelBundle::new()
    .with_name(&quot;sentiment-v1&quot;)
    .with_description(&quot;BERT-based sentiment classifier&quot;)
    .with_compression(true)
    .with_payload(model_weights)
    .build();</code></pre>
<h2 id="builder-methods"><a class="header" href="#builder-methods">Builder Methods</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>with_name(s)</code></td><td>Set model name (max 255 chars)</td></tr>
<tr><td><code>with_description(s)</code></td><td>Set description (optional)</td></tr>
<tr><td><code>with_compression(bool)</code></td><td>Enable zstd compression</td></tr>
<tr><td><code>with_payload(bytes)</code></td><td>Set model weights</td></tr>
<tr><td><code>build()</code></td><td>Create the APR bundle</td></tr>
</tbody></table>
</div>
<h2 id="loading-bundles"><a class="header" href="#loading-bundles">Loading Bundles</a></h2>
<pre><code class="language-rust">use apr_cookbook::bundle::BundledModel;

// From bytes (zero-copy)
let model = BundledModel::from_bytes(&amp;bundle_bytes)?;

// Access metadata
println!(&quot;Name: {}&quot;, model.name());
println!(&quot;Version: {:?}&quot;, model.version());
println!(&quot;Size: {} bytes&quot;, model.size());

// Check flags
if model.is_compressed() {
    println!(&quot;Payload is compressed&quot;);
}</code></pre>
<h2 id="bundledmodel-methods"><a class="header" href="#bundledmodel-methods">BundledModel Methods</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Returns</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name()</code></td><td><code>&amp;str</code></td><td>Model name</td></tr>
<tr><td><code>version()</code></td><td><code>(u8, u8)</code></td><td>Format version</td></tr>
<tr><td><code>size()</code></td><td><code>usize</code></td><td>Total size in bytes</td></tr>
<tr><td><code>is_compressed()</code></td><td><code>bool</code></td><td>Compression flag</td></tr>
<tr><td><code>is_encrypted()</code></td><td><code>bool</code></td><td>Encryption flag</td></tr>
<tr><td><code>is_signed()</code></td><td><code>bool</code></td><td>Signature flag</td></tr>
<tr><td><code>as_bytes()</code></td><td><code>&amp;[u8]</code></td><td>Raw bundle bytes</td></tr>
</tbody></table>
</div>
<h2 id="compile-time-embedding"><a class="header" href="#compile-time-embedding">Compile-Time Embedding</a></h2>
<p>The recommended pattern for production:</p>
<pre><code class="language-rust">// Embed at compile time
const MODEL: &amp;[u8] = include_bytes!(&quot;models/classifier.apr&quot;);

fn get_model() -&gt; BundledModel&lt;'static&gt; {
    // This never fails if the file is valid APR
    BundledModel::from_bytes(MODEL).expect(&quot;embedded model is valid&quot;)
}</code></pre>
<p>Benefits:</p>
<ul>
<li>No file I/O at runtime</li>
<li>Model integrity verified at compile time</li>
<li>Single binary deployment</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format-conversion"><a class="header" href="#format-conversion">Format Conversion</a></h1>
<p>Convert models between APR, SafeTensors, and GGUF formats.</p>
<h2 id="supported-conversions"><a class="header" href="#supported-conversions">Supported Conversions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>From</th><th>To</th><th>Supported</th></tr></thead><tbody>
<tr><td>SafeTensors</td><td>APR</td><td>✅</td></tr>
<tr><td>GGUF</td><td>APR</td><td>✅</td></tr>
<tr><td>APR</td><td>GGUF</td><td>✅</td></tr>
<tr><td>APR</td><td>SafeTensors</td><td>✅</td></tr>
</tbody></table>
</div>
<h2 id="using-aprconverter"><a class="header" href="#using-aprconverter">Using AprConverter</a></h2>
<pre><code class="language-rust">use apr_cookbook::convert::{AprConverter, TensorData, DataType, ConversionMetadata};

// Create converter
let mut converter = AprConverter::new();

// Set metadata
converter.set_metadata(ConversionMetadata {
    name: Some(&quot;my-model&quot;.to_string()),
    architecture: Some(&quot;transformer&quot;.to_string()),
    ..Default::default()
});

// Add tensors
converter.add_tensor(TensorData {
    name: &quot;embed.weight&quot;.to_string(),
    shape: vec![32000, 4096],
    dtype: DataType::F16,
    data: embedding_bytes,
});

// Generate APR
let apr_bytes = converter.to_apr()?;</code></pre>
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Size</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>F32</code></td><td>4 bytes</td><td>Full precision</td></tr>
<tr><td><code>F16</code></td><td>2 bytes</td><td>Half precision</td></tr>
<tr><td><code>BF16</code></td><td>2 bytes</td><td>Brain float</td></tr>
<tr><td><code>Q8_0</code></td><td>1 byte</td><td>8-bit quantized</td></tr>
<tr><td><code>Q4_0</code></td><td>0.5 byte</td><td>4-bit quantized</td></tr>
</tbody></table>
</div>
<h2 id="checking-support"><a class="header" href="#checking-support">Checking Support</a></h2>
<pre><code class="language-rust">use apr_cookbook::convert::{AprConverter, ConversionFormat};

let supported = AprConverter::is_conversion_supported(
    ConversionFormat::Gguf,
    ConversionFormat::Apr
);
assert!(supported);</code></pre>
<h2 id="format-detection"><a class="header" href="#format-detection">Format Detection</a></h2>
<pre><code class="language-rust">use apr_cookbook::convert::ConversionFormat;

let format = ConversionFormat::from_extension(&quot;safetensors&quot;);
assert_eq!(format, Some(ConversionFormat::SafeTensors));

let format = ConversionFormat::from_path(&quot;model.gguf&quot;);
assert_eq!(format, Some(ConversionFormat::Gguf));</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zero-copy-loading"><a class="header" href="#zero-copy-loading">Zero-Copy Loading</a></h1>
<p>Zero-copy loading eliminates memory copies when loading models, reducing latency and memory usage.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>Traditional loading:</p>
<pre><code>File → Read to buffer → Parse → Copy to model struct → Use
        ↓                        ↓
     Allocation              Allocation
</code></pre>
<p>Zero-copy loading:</p>
<pre><code>Memory (file/include_bytes!) → Interpret in place → Use
                                    ↓
                              No allocations
</code></pre>
<h2 id="the-include_bytes-pattern"><a class="header" href="#the-include_bytes-pattern">The <code>include_bytes!()</code> Pattern</a></h2>
<pre><code class="language-rust">// Model bytes are in the binary's .rodata section
const MODEL: &amp;[u8] = include_bytes!(&quot;model.apr&quot;);

fn main() {
    // BundledModel borrows from MODEL, no copies
    let model = BundledModel::from_bytes(MODEL).unwrap();

    // model.as_bytes() returns the original slice
    assert!(std::ptr::eq(MODEL.as_ptr(), model.as_bytes().as_ptr()));
}</code></pre>
<h2 id="memory-layout"><a class="header" href="#memory-layout">Memory Layout</a></h2>
<pre><code>Binary .rodata section:
┌──────────────────────────────────────────┐
│ ... other static data ...                │
│ MODEL: [APRN header | metadata | payload]│
│ ... other static data ...                │
└──────────────────────────────────────────┘
         ↑
         │ BundledModel references this directly
         │ No heap allocations
</code></pre>
<h2 id="benefits"><a class="header" href="#benefits">Benefits</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Traditional</th><th>Zero-Copy</th></tr></thead><tbody>
<tr><td>Load time</td><td>~100ms</td><td>~1ms</td></tr>
<tr><td>Memory overhead</td><td>2x model size</td><td>0</td></tr>
<tr><td>Allocations</td><td>2+</td><td>0</td></tr>
</tbody></table>
</div>
<h2 id="when-to-use"><a class="header" href="#when-to-use">When to Use</a></h2>
<p>✅ <strong>Use zero-copy when:</strong></p>
<ul>
<li>Model is embedded via <code>include_bytes!()</code></li>
<li>Model is memory-mapped</li>
<li>Model lifetime matches application lifetime</li>
</ul>
<p>❌ <strong>Don't use when:</strong></p>
<ul>
<li>Model needs modification</li>
<li>Model comes from untrusted source (validate first)</li>
<li>Model needs to outlive source buffer</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bundle-a-static-model"><a class="header" href="#bundle-a-static-model">Bundle a Static Model</a></h1>
<p>Embed a model directly in your Rust binary for single-file deployment.</p>
<h2 id="recipe"><a class="header" href="#recipe">Recipe</a></h2>
<pre><code class="language-rust">use apr_cookbook::bundle::{BundledModel, ModelBundle};

// Step 1: Create the bundle (build script or offline)
fn create_bundle() {
    let weights = std::fs::read(&quot;trained_model.bin&quot;).unwrap();

    let bundle = ModelBundle::new()
        .with_name(&quot;sentiment-classifier&quot;)
        .with_description(&quot;Binary sentiment classification&quot;)
        .with_payload(weights)
        .build();

    std::fs::write(&quot;src/models/sentiment.apr&quot;, bundle).unwrap();
}

// Step 2: Embed at compile time
const MODEL: &amp;[u8] = include_bytes!(&quot;models/sentiment.apr&quot;);

// Step 3: Load and use
fn classify(text: &amp;str) -&gt; bool {
    let model = BundledModel::from_bytes(MODEL).unwrap();
    // Use model for inference...
    true
}</code></pre>
<h2 id="run-the-example"><a class="header" href="#run-the-example">Run the Example</a></h2>
<pre><code class="language-bash">cargo run --example bundle_static_model
</code></pre>
<h2 id="output"><a class="header" href="#output">Output</a></h2>
<pre><code>=== APR Cookbook: Static Model Bundling ===

Creating model bundle...
  Name: sentiment-classifier
  Payload: 1000 bytes

Bundle created: 1048 bytes
  Magic: APRN
  Version: 1.0
  Compressed: no

Loading from bytes...
  Model loaded successfully
  Name: sentiment-classifier
  Size: 1048 bytes

[SUCCESS] Static bundling complete!
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Version your models</strong> - Include version in the name</li>
<li><strong>Validate at build time</strong> - Catch errors before deployment</li>
<li><strong>Use compression</strong> - Reduce binary size for large models</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bundle-with-quantization"><a class="header" href="#bundle-with-quantization">Bundle with Quantization</a></h1>
<p>Reduce model size 4-8x using quantization while maintaining accuracy.</p>
<h2 id="quantization-levels"><a class="header" href="#quantization-levels">Quantization Levels</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Level</th><th>Bits</th><th>Size Reduction</th><th>Accuracy Loss</th></tr></thead><tbody>
<tr><td>F32</td><td>32</td><td>1x (baseline)</td><td>None</td></tr>
<tr><td>F16</td><td>16</td><td>2x</td><td>Minimal</td></tr>
<tr><td>Q8_0</td><td>8</td><td>4x</td><td>Low</td></tr>
<tr><td>Q4_0</td><td>4</td><td>8x</td><td>Moderate</td></tr>
</tbody></table>
</div>
<h2 id="recipe-1"><a class="header" href="#recipe-1">Recipe</a></h2>
<pre><code class="language-rust">use apr_cookbook::convert::{AprConverter, TensorData, DataType};

fn quantize_model(weights: &amp;[f32], target: DataType) -&gt; Vec&lt;u8&gt; {
    match target {
        DataType::Q8_0 =&gt; {
            // Quantize to 8-bit
            weights.iter()
                .map(|&amp;w| ((w.clamp(-1.0, 1.0) + 1.0) * 127.5) as u8)
                .collect()
        }
        DataType::Q4_0 =&gt; {
            // Quantize to 4-bit (pack 2 values per byte)
            weights.chunks(2)
                .map(|pair| {
                    let a = ((pair[0].clamp(-1.0, 1.0) + 1.0) * 7.5) as u8;
                    let b = pair.get(1)
                        .map(|&amp;w| ((w.clamp(-1.0, 1.0) + 1.0) * 7.5) as u8)
                        .unwrap_or(0);
                    (a &lt;&lt; 4) | b
                })
                .collect()
        }
        _ =&gt; unimplemented!()
    }
}

fn main() {
    let mut converter = AprConverter::new();

    // Original F32 weights: 4 bytes per weight
    let f32_weights: Vec&lt;f32&gt; = vec![0.1, -0.5, 0.8, 0.0];

    // Quantize to Q8_0: 1 byte per weight (4x smaller)
    let q8_data = quantize_model(&amp;f32_weights, DataType::Q8_0);

    converter.add_tensor(TensorData {
        name: &quot;layer.weight&quot;.to_string(),
        shape: vec![2, 2],
        dtype: DataType::Q8_0,
        data: q8_data,
    });

    let bundle = converter.to_apr().unwrap();
    println!(&quot;Quantized bundle: {} bytes&quot;, bundle.len());
}</code></pre>
<h2 id="run-the-example-1"><a class="header" href="#run-the-example-1">Run the Example</a></h2>
<pre><code class="language-bash">cargo run --example bundle_quantized_model
</code></pre>
<h2 id="when-to-quantize"><a class="header" href="#when-to-quantize">When to Quantize</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Model Size</th><th>Recommendation</th></tr></thead><tbody>
<tr><td>&lt; 10 MB</td><td>F32 (no quantization)</td></tr>
<tr><td>10-100 MB</td><td>F16 or Q8_0</td></tr>
<tr><td>100 MB - 1 GB</td><td>Q8_0</td></tr>
<tr><td>&gt; 1 GB</td><td>Q4_0</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="encrypt-a-model"><a class="header" href="#encrypt-a-model">Encrypt a Model</a></h1>
<p>Protect proprietary models with AES-256-GCM encryption.</p>
<h2 id="security-features"><a class="header" href="#security-features">Security Features</a></h2>
<ul>
<li><strong>AES-256-GCM</strong> - Authenticated encryption (AEAD)</li>
<li><strong>Argon2id</strong> - Memory-hard key derivation (resists GPU attacks)</li>
<li><strong>Random nonce</strong> - Unique per encryption (prevents IV reuse)</li>
</ul>
<h2 id="recipe-2"><a class="header" href="#recipe-2">Recipe</a></h2>
<pre><code class="language-rust">use aprender::format::{
    save_encrypted, load_encrypted, load_from_bytes_encrypted,
    ModelType, SaveOptions
};

// Save encrypted
save_encrypted(
    &amp;model,
    ModelType::Custom,
    &quot;model.apr.enc&quot;,
    SaveOptions::default().with_name(&quot;proprietary-model&quot;),
    &quot;secure_password_123&quot;,
)?;

// Load encrypted
let model: MyModel = load_encrypted(
    &quot;model.apr.enc&quot;,
    ModelType::Custom,
    &quot;secure_password_123&quot;
)?;

// Load from embedded bytes
const ENCRYPTED: &amp;[u8] = include_bytes!(&quot;model.apr.enc&quot;);
let model: MyModel = load_from_bytes_encrypted(
    ENCRYPTED,
    ModelType::Custom,
    password
)?;</code></pre>
<h2 id="run-the-example-2"><a class="header" href="#run-the-example-2">Run the Example</a></h2>
<pre><code class="language-bash">cargo run --example bundle_encrypted_model --features encryption
</code></pre>
<h2 id="output-1"><a class="header" href="#output-1">Output</a></h2>
<pre><code>=== APR Cookbook: Encrypted Model Bundling ===

Created sentiment classifier:
  Vocabulary size: 1000
  Embedding dimension: 64

Saving encrypted model...
File sizes:
  Unencrypted: 256128 bytes
  Encrypted:   256176 bytes (+48 bytes overhead)

Loading encrypted model with correct password...
  ✓ Model loaded successfully
  ✓ Decryption verified

Testing wrong password...
  ✓ Correctly rejected wrong password

[SUCCESS] Encrypted model demonstration complete!
</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Use strong passwords</strong> - 16+ characters, mixed case/numbers/symbols</li>
<li><strong>Rotate keys</strong> - Re-encrypt periodically</li>
<li><strong>Secure key storage</strong> - Use environment variables or secret managers</li>
<li><strong>Never hardcode passwords</strong> - Pass at runtime</li>
</ol>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Threat</th><th>Protection</th></tr></thead><tbody>
<tr><td>Disk theft</td><td>Encrypted at rest</td></tr>
<tr><td>Memory dump</td><td>Decrypted only when needed</td></tr>
<tr><td>Brute force</td><td>Argon2id slows attacks</td></tr>
<tr><td>Tampering</td><td>GCM authentication tag</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="convert-from-safetensors"><a class="header" href="#convert-from-safetensors">Convert from SafeTensors</a></h1>
<p>Import Hugging Face SafeTensors models into APR format.</p>
<h2 id="recipe-3"><a class="header" href="#recipe-3">Recipe</a></h2>
<pre><code class="language-rust">use apr_cookbook::convert::{AprConverter, TensorData, DataType, ConversionMetadata};

fn convert_safetensors(path: &amp;str) -&gt; apr_cookbook::Result&lt;Vec&lt;u8&gt;&gt; {
    // In production, use the safetensors crate to read the file
    // Here we demonstrate the conversion pattern

    let mut converter = AprConverter::new();

    converter.set_metadata(ConversionMetadata {
        name: Some(&quot;bert-base&quot;.to_string()),
        architecture: Some(&quot;transformer&quot;.to_string()),
        source_format: Some(apr_cookbook::convert::ConversionFormat::SafeTensors),
        ..Default::default()
    });

    // Add each tensor from SafeTensors
    converter.add_tensor(TensorData {
        name: &quot;embeddings.word_embeddings.weight&quot;.to_string(),
        shape: vec![30522, 768],
        dtype: DataType::F32,
        data: vec![0u8; 30522 * 768 * 4], // Placeholder
    });

    converter.to_apr()
}</code></pre>
<h2 id="run-the-example-3"><a class="header" href="#run-the-example-3">Run the Example</a></h2>
<pre><code class="language-bash">cargo run --example convert_safetensors_to_apr
</code></pre>
<h2 id="output-2"><a class="header" href="#output-2">Output</a></h2>
<pre><code>=== APR Cookbook: SafeTensors → APR Conversion ===

Conversion supported: true

Simulating SafeTensors model...
  Tensors: 5
  Total parameters: 110M

Converting to APR...
  ✓ Token embeddings: [30522, 768]
  ✓ Position embeddings: [512, 768]
  ✓ Attention weights: [768, 768]
  ✓ FFN weights: [768, 3072]
  ✓ Output weights: [768, 30522]

Conversion complete:
  APR size: 440MB
  Tensors: 5
  Parameters: 110M

[SUCCESS] SafeTensors → APR conversion complete!
</code></pre>
<h2 id="why-convert"><a class="header" href="#why-convert">Why Convert?</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>SafeTensors</th><th>APR</th></tr></thead><tbody>
<tr><td>Zero-copy</td><td>✅</td><td>✅</td></tr>
<tr><td>Encryption</td><td>❌</td><td>✅</td></tr>
<tr><td>Compression</td><td>❌</td><td>✅</td></tr>
<tr><td>include_bytes!</td><td>✅</td><td>✅</td></tr>
<tr><td>Rust-native</td><td>❌</td><td>✅</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="convert-from-gguf"><a class="header" href="#convert-from-gguf">Convert from GGUF</a></h1>
<p>Import llama.cpp GGUF models into APR format.</p>
<h2 id="why-import-gguf"><a class="header" href="#why-import-gguf">Why Import GGUF?</a></h2>
<p>GGUF is the de-facto standard for quantized LLMs:</p>
<ul>
<li>Thousands of models on Hugging Face</li>
<li>Ollama model library</li>
<li>TheBloke quantizations</li>
</ul>
<p>Converting to APR enables:</p>
<ul>
<li>Pure Rust inference (no C++ deps)</li>
<li>WASM deployment</li>
<li>Native trueno SIMD acceleration</li>
</ul>
<h2 id="recipe-4"><a class="header" href="#recipe-4">Recipe</a></h2>
<pre><code class="language-rust">use apr_cookbook::convert::{AprConverter, TensorData, DataType, ConversionMetadata, ConversionFormat};

fn main() -&gt; apr_cookbook::Result&lt;()&gt; {
    // Verify conversion is supported
    assert!(AprConverter::is_conversion_supported(
        ConversionFormat::Gguf,
        ConversionFormat::Apr
    ));

    let mut converter = AprConverter::new();

    converter.set_metadata(ConversionMetadata {
        name: Some(&quot;llama-7b-q4&quot;.to_string()),
        architecture: Some(&quot;llama&quot;.to_string()),
        source_format: Some(ConversionFormat::Gguf),
        ..Default::default()
    });

    // Add tensors from GGUF
    // In production, parse GGUF header and extract tensors
    converter.add_tensor(TensorData {
        name: &quot;token_embd.weight&quot;.to_string(),
        shape: vec![32000, 4096],
        dtype: DataType::Q8_0,
        data: vec![0u8; 32000 * 4096],
    });

    let apr_bytes = converter.to_apr()?;
    println!(&quot;Converted: {} bytes&quot;, apr_bytes.len());

    Ok(())
}</code></pre>
<h2 id="run-the-example-4"><a class="header" href="#run-the-example-4">Run the Example</a></h2>
<pre><code class="language-bash">cargo run --example convert_gguf_to_apr
</code></pre>
<h2 id="ggml-type-mapping"><a class="header" href="#ggml-type-mapping">GGML Type Mapping</a></h2>
<div class="table-wrapper"><table><thead><tr><th>GGML Type</th><th>APR Type</th></tr></thead><tbody>
<tr><td>F32</td><td>F32</td></tr>
<tr><td>F16</td><td>F16</td></tr>
<tr><td>Q4_0</td><td>Q4_0</td></tr>
<tr><td>Q4_1</td><td>Q4_0</td></tr>
<tr><td>Q8_0</td><td>Q8_0</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="export-to-gguf"><a class="header" href="#export-to-gguf">Export to GGUF</a></h1>
<p>Export APR models to GGUF format for use with llama.cpp ecosystem.</p>
<h2 id="recipe-5"><a class="header" href="#recipe-5">Recipe</a></h2>
<pre><code class="language-rust">use apr_cookbook::convert::{AprConverter, ConversionFormat};

fn export_to_gguf(apr_bytes: &amp;[u8]) -&gt; apr_cookbook::Result&lt;Vec&lt;u8&gt;&gt; {
    assert!(AprConverter::is_conversion_supported(
        ConversionFormat::Apr,
        ConversionFormat::Gguf
    ));

    // Load APR model
    let model = apr_cookbook::bundle::BundledModel::from_bytes(apr_bytes)?;

    // Export to GGUF format
    // Implementation depends on model architecture
    todo!(&quot;GGUF export implementation&quot;)
}</code></pre>
<h2 id="run-the-example-5"><a class="header" href="#run-the-example-5">Run the Example</a></h2>
<pre><code class="language-bash">cargo run --example convert_apr_to_gguf
</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<ul>
<li>Run APR-trained models in Ollama</li>
<li>Use with llama.cpp for CPU inference</li>
<li>Share models with GGUF ecosystem</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simd-acceleration"><a class="header" href="#simd-acceleration">SIMD Acceleration</a></h1>
<p>Leverage CPU SIMD instructions for faster inference via trueno integration.</p>
<h2 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Instructions</th><th>Auto-detected</th></tr></thead><tbody>
<tr><td>x86_64</td><td>AVX2, AVX-512</td><td>✅</td></tr>
<tr><td>ARM64</td><td>NEON</td><td>✅</td></tr>
<tr><td>WASM</td><td>SIMD128</td><td>✅</td></tr>
</tbody></table>
</div>
<h2 id="recipe-6"><a class="header" href="#recipe-6">Recipe</a></h2>
<pre><code class="language-rust">use trueno::simd::{SimdBackend, detect_best_backend};

fn main() {
    // Auto-detect best SIMD backend
    let backend = detect_best_backend();
    println!(&quot;Using: {:?}&quot;, backend);

    // Matrix multiplication with SIMD
    let a = vec![1.0f32; 1024 * 1024];
    let b = vec![1.0f32; 1024 * 1024];

    let start = std::time::Instant::now();
    let c = backend.matmul(&amp;a, &amp;b, 1024, 1024, 1024);
    println!(&quot;MatMul: {:?}&quot;, start.elapsed());
}</code></pre>
<h2 id="run-the-example-6"><a class="header" href="#run-the-example-6">Run the Example</a></h2>
<pre><code class="language-bash">cargo run --example simd_matrix_operations --release
</code></pre>
<h2 id="performance-comparison"><a class="header" href="#performance-comparison">Performance Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Scalar</th><th>AVX2</th><th>Speedup</th></tr></thead><tbody>
<tr><td>1024x1024 MatMul</td><td>2100ms</td><td>85ms</td><td>25x</td></tr>
<tr><td>Vector dot</td><td>45μs</td><td>3μs</td><td>15x</td></tr>
<tr><td>Element-wise</td><td>12μs</td><td>1μs</td><td>12x</td></tr>
</tbody></table>
</div>
<h2 id="fallback-behavior"><a class="header" href="#fallback-behavior">Fallback Behavior</a></h2>
<p>trueno automatically falls back to scalar operations when SIMD is unavailable:</p>
<pre><code class="language-rust">// This works on all platforms
let result = backend.add(&amp;a, &amp;b);

// On x86_64 with AVX2: uses SIMD
// On older x86_64: uses scalar fallback
// On WASM: uses SIMD128 if available</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apr-info"><a class="header" href="#apr-info">apr-info</a></h1>
<p>Display APR model information and metadata.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-bash">cargo run --example apr_info -- [OPTIONS] [FILE]
</code></pre>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody>
<tr><td><code>FILE</code></td><td>Path to APR model file</td></tr>
<tr><td><code>--demo</code></td><td>Use demo mode with sample model</td></tr>
<tr><td><code>-v, --verbose</code></td><td>Show verbose output (hex dump)</td></tr>
<tr><td><code>-h, --help</code></td><td>Print help</td></tr>
<tr><td><code>-V, --version</code></td><td>Print version</td></tr>
</tbody></table>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<pre><code class="language-bash"># Inspect a model file
cargo run --example apr_info -- model.apr

# Demo mode
cargo run --example apr_info -- --demo

# Verbose output
cargo run --example apr_info -- --verbose model.apr
</code></pre>
<h2 id="output-3"><a class="header" href="#output-3">Output</a></h2>
<pre><code>=== APR Model Info ===

Name:        sentiment-classifier
Size:        1048576 bytes
Version:     1.0

Flags:
  Compressed: yes
  Encrypted:  no
  Signed:     no
</code></pre>
<h2 id="verbose-output"><a class="header" href="#verbose-output">Verbose Output</a></h2>
<p>With <code>--verbose</code>, includes hex dump of header:</p>
<pre><code>Header (hex):
  0000: 41 50 52 4e 01 00 01 00 00 00 00 00 00 10 00 00
  0010: 73 65 6e 74 69 6d 65 6e 74 2d 63 6c 61 73 73 69
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apr-bench"><a class="header" href="#apr-bench">apr-bench</a></h1>
<p>Benchmark APR model inference performance.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<pre><code class="language-bash">cargo run --example apr_bench --release -- [OPTIONS] [FILE]
</code></pre>
<h2 id="options-1"><a class="header" href="#options-1">Options</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>FILE</code></td><td>Path to APR model file</td><td>-</td></tr>
<tr><td><code>--demo</code></td><td>Use demo mode</td><td>false</td></tr>
<tr><td><code>-i, --iterations</code></td><td>Number of iterations</td><td>1000</td></tr>
<tr><td><code>-w, --warmup</code></td><td>Warmup iterations</td><td>100</td></tr>
<tr><td><code>-b, --batch-size</code></td><td>Batch size</td><td>1</td></tr>
</tbody></table>
</div>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<pre><code class="language-bash"># Benchmark with defaults
cargo run --example apr_bench --release -- model.apr

# Demo mode
cargo run --example apr_bench --release -- --demo

# Custom iterations
cargo run --example apr_bench --release -- --iterations 10000 model.apr
</code></pre>
<h2 id="output-4"><a class="header" href="#output-4">Output</a></h2>
<pre><code>=== APR Cookbook: Model Benchmark ===

Model: sentiment-classifier.apr

Model size:    1048576 bytes
Batch size:    1
Warmup:        100 iterations
Benchmark:     1000 iterations

Running benchmark...

=== Benchmark Results ===

Iterations:    1000
Total time:    45.23ms

Latency:
  Mean:        45.23μs
  Min:         42.10μs
  Max:         112.50μs
  P50:         44.00μs
  P99:         89.00μs

Throughput:    22109.22 inferences/sec
</code></pre>
<h2 id="interpreting-results"><a class="header" href="#interpreting-results">Interpreting Results</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Good</th><th>Acceptable</th><th>Needs Work</th></tr></thead><tbody>
<tr><td>P50 latency</td><td>&lt;1ms</td><td>&lt;10ms</td><td>&gt;10ms</td></tr>
<tr><td>P99 latency</td><td>&lt;5ms</td><td>&lt;50ms</td><td>&gt;50ms</td></tr>
<tr><td>Throughput</td><td>&gt;1000/s</td><td>&gt;100/s</td><td>&lt;100/s</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="wasm-deployment"><a class="header" href="#wasm-deployment">WASM Deployment</a></h1>
<p>Deploy APR models to browsers and edge functions.</p>
<h2 id="building-for-wasm"><a class="header" href="#building-for-wasm">Building for WASM</a></h2>
<pre><code class="language-bash"># Install target
rustup target add wasm32-unknown-unknown

# Build
cargo build --target wasm32-unknown-unknown --release
</code></pre>
<h2 id="wasm-compatible-code"><a class="header" href="#wasm-compatible-code">WASM-Compatible Code</a></h2>
<pre><code class="language-rust">use apr_cookbook::bundle::BundledModel;

// Works in WASM - no file I/O
const MODEL: &amp;[u8] = include_bytes!(&quot;model.apr&quot;);

#[cfg(target_arch = &quot;wasm32&quot;)]
use wasm_bindgen::prelude::*;

#[cfg_attr(target_arch = &quot;wasm32&quot;, wasm_bindgen)]
pub fn load_model() -&gt; Result&lt;JsValue, JsValue&gt; {
    let model = BundledModel::from_bytes(MODEL)
        .map_err(|e| JsValue::from_str(&amp;e.to_string()))?;

    Ok(JsValue::from_str(model.name()))
}</code></pre>
<h2 id="javascript-usage"><a class="header" href="#javascript-usage">JavaScript Usage</a></h2>
<pre><code class="language-javascript">import init, { load_model } from './pkg/my_model.js';

async function main() {
    await init();
    const name = load_model();
    console.log(`Loaded model: ${name}`);
}

main();
</code></pre>
<h2 id="size-optimization"><a class="header" href="#size-optimization">Size Optimization</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Technique</th><th>Size Reduction</th></tr></thead><tbody>
<tr><td><code>--release</code></td><td>50-70%</td></tr>
<tr><td><code>opt-level = 'z'</code></td><td>10-20%</td></tr>
<tr><td><code>wasm-opt -Oz</code></td><td>5-15%</td></tr>
<tr><td><code>lto = true</code></td><td>10-20%</td></tr>
</tbody></table>
</div>
<h2 id="cargotoml-for-wasm"><a class="header" href="#cargotoml-for-wasm">Cargo.toml for WASM</a></h2>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
lto = true
codegen-units = 1
panic = 'abort'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-model-types"><a class="header" href="#custom-model-types">Custom Model Types</a></h1>
<p>Define custom model types for specialized use cases.</p>
<h2 id="implementing-a-custom-model"><a class="header" href="#implementing-a-custom-model">Implementing a Custom Model</a></h2>
<pre><code class="language-rust">use serde::{Serialize, Deserialize};
use aprender::format::{save, load, ModelType, SaveOptions};

#[derive(Debug, Serialize, Deserialize)]
struct MyCustomModel {
    layers: Vec&lt;Layer&gt;,
    vocab_size: usize,
    hidden_dim: usize,
}

#[derive(Debug, Serialize, Deserialize)]
struct Layer {
    weights: Vec&lt;f32&gt;,
    biases: Vec&lt;f32&gt;,
}

impl MyCustomModel {
    fn new(vocab_size: usize, hidden_dim: usize) -&gt; Self {
        Self {
            layers: vec![],
            vocab_size,
            hidden_dim,
        }
    }

    fn save(&amp;self, path: &amp;str) -&gt; apr_cookbook::Result&lt;()&gt; {
        save(
            self,
            ModelType::Custom,
            path,
            SaveOptions::default()
                .with_name(&quot;my-model&quot;)
                .with_compression(true),
        )?;
        Ok(())
    }

    fn load(path: &amp;str) -&gt; apr_cookbook::Result&lt;Self&gt; {
        Ok(load(path, ModelType::Custom)?)
    }
}</code></pre>
<h2 id="model-type-guidelines"><a class="header" href="#model-type-guidelines">Model Type Guidelines</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Model Type</th><th>Use Case</th></tr></thead><tbody>
<tr><td><code>ModelType::Custom</code></td><td>Generic serializable structs</td></tr>
<tr><td><code>ModelType::LinearRegression</code></td><td>Linear models</td></tr>
<tr><td><code>ModelType::NeuralNetwork</code></td><td>Neural network weights</td></tr>
<tr><td><code>ModelType::Transformer</code></td><td>Transformer architectures</td></tr>
</tbody></table>
</div>
<h2 id="validation"><a class="header" href="#validation">Validation</a></h2>
<p>Always validate loaded models:</p>
<pre><code class="language-rust">impl MyCustomModel {
    fn validate(&amp;self) -&gt; apr_cookbook::Result&lt;()&gt; {
        if self.layers.is_empty() {
            return Err(apr_cookbook::CookbookError::invalid_format(
                &quot;model has no layers&quot;
            ));
        }
        Ok(())
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h1>
<p>Maximize inference performance with these techniques.</p>
<h2 id="optimization-checklist"><a class="header" href="#optimization-checklist">Optimization Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Use <code>--release</code> builds</li>
<li><input disabled="" type="checkbox"/>
Enable LTO (link-time optimization)</li>
<li><input disabled="" type="checkbox"/>
Use <code>include_bytes!()</code> for models</li>
<li><input disabled="" type="checkbox"/>
Enable SIMD via trueno</li>
<li><input disabled="" type="checkbox"/>
Profile before optimizing</li>
</ul>
<h2 id="cargotoml-settings"><a class="header" href="#cargotoml-settings">Cargo.toml Settings</a></h2>
<pre><code class="language-toml">[profile.release]
opt-level = 3
lto = &quot;fat&quot;
codegen-units = 1
panic = &quot;abort&quot;

[profile.release.package.&quot;*&quot;]
opt-level = 3
</code></pre>
<h2 id="memory-layout-1"><a class="header" href="#memory-layout-1">Memory Layout</a></h2>
<p>Optimize tensor memory layout:</p>
<pre><code class="language-rust">// Prefer contiguous arrays
let weights: Vec&lt;f32&gt; = vec![0.0; rows * cols];

// Access in row-major order
for i in 0..rows {
    for j in 0..cols {
        let idx = i * cols + j;
        process(weights[idx]);
    }
}</code></pre>
<h2 id="batch-processing"><a class="header" href="#batch-processing">Batch Processing</a></h2>
<p>Process multiple inputs together:</p>
<pre><code class="language-rust">fn infer_batch(model: &amp;Model, inputs: &amp;[Input]) -&gt; Vec&lt;Output&gt; {
    // Single model load, multiple inferences
    inputs.iter()
        .map(|input| model.infer(input))
        .collect()
}</code></pre>
<h2 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h2>
<p>Use criterion for reliable benchmarks:</p>
<pre><code class="language-rust">use criterion::{criterion_group, criterion_main, Criterion};

fn benchmark_inference(c: &amp;mut Criterion) {
    let model = load_model();
    let input = create_test_input();

    c.bench_function(&quot;inference&quot;, |b| {
        b.iter(|| model.infer(&amp;input))
    });
}

criterion_group!(benches, benchmark_inference);
criterion_main!(benches);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h1>
<p>Complete API reference for apr-cookbook.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<h3 id="apr_cookbookbundle"><a class="header" href="#apr_cookbookbundle"><code>apr_cookbook::bundle</code></a></h3>
<p>Model bundling and loading.</p>
<pre><code class="language-rust">pub struct ModelBundle { ... }
pub struct BundledModel&lt;'a&gt; { ... }</code></pre>
<h3 id="apr_cookbookconvert"><a class="header" href="#apr_cookbookconvert"><code>apr_cookbook::convert</code></a></h3>
<p>Format conversion utilities.</p>
<pre><code class="language-rust">pub struct AprConverter { ... }
pub struct TensorData { ... }
pub enum ConversionFormat { ... }
pub enum DataType { ... }</code></pre>
<h3 id="apr_cookbookerror"><a class="header" href="#apr_cookbookerror"><code>apr_cookbook::error</code></a></h3>
<p>Error types.</p>
<pre><code class="language-rust">pub enum CookbookError { ... }
pub type Result&lt;T&gt; = std::result::Result&lt;T, CookbookError&gt;;</code></pre>
<h2 id="full-documentation"><a class="header" href="#full-documentation">Full Documentation</a></h2>
<p>Generated API docs are available at:</p>
<ul>
<li><a href="https://docs.rs/apr-cookbook">docs.rs/apr-cookbook</a></li>
</ul>
<p>Or generate locally:</p>
<pre><code class="language-bash">cargo doc --all-features --open
</code></pre>
<h2 id="stability"><a class="header" href="#stability">Stability</a></h2>
<div class="table-wrapper"><table><thead><tr><th>API</th><th>Stability</th></tr></thead><tbody>
<tr><td><code>bundle::*</code></td><td>Stable</td></tr>
<tr><td><code>convert::*</code></td><td>Stable</td></tr>
<tr><td><code>error::*</code></td><td>Stable</td></tr>
<tr><td><code>aprender_integration::*</code></td><td>Experimental</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<p>Comprehensive error handling with <code>CookbookError</code>.</p>
<h2 id="error-types"><a class="header" href="#error-types">Error Types</a></h2>
<pre><code class="language-rust">pub enum CookbookError {
    /// Invalid APR format
    InvalidFormat { message: String },

    /// Model file not found
    ModelNotFound { path: PathBuf },

    /// Feature not available
    FeatureNotAvailable { feature: String },

    /// Dimension mismatch
    DimensionMismatch { expected: Vec&lt;usize&gt;, got: Vec&lt;usize&gt; },

    /// Conversion failed
    ConversionFailed { message: String },

    /// IO error
    Io(std::io::Error),

    /// Aprender error
    Aprender(String),
}</code></pre>
<h2 id="handling-errors"><a class="header" href="#handling-errors">Handling Errors</a></h2>
<pre><code class="language-rust">use apr_cookbook::{Result, CookbookError};

fn load_model(path: &amp;str) -&gt; Result&lt;Model&gt; {
    let bytes = std::fs::read(path)?;  // Converts io::Error

    let model = BundledModel::from_bytes(&amp;bytes)?;

    if !model.is_compatible() {
        return Err(CookbookError::invalid_format(&quot;incompatible version&quot;));
    }

    Ok(model)
}

// Pattern matching
match load_model(&quot;model.apr&quot;) {
    Ok(model) =&gt; println!(&quot;Loaded: {}&quot;, model.name()),
    Err(CookbookError::ModelNotFound { path }) =&gt; {
        eprintln!(&quot;File not found: {}&quot;, path.display());
    }
    Err(CookbookError::InvalidFormat { message }) =&gt; {
        eprintln!(&quot;Invalid format: {}&quot;, message);
    }
    Err(e) =&gt; eprintln!(&quot;Error: {}&quot;, e),
}</code></pre>
<h2 id="creating-errors"><a class="header" href="#creating-errors">Creating Errors</a></h2>
<pre><code class="language-rust">// Use helper methods
CookbookError::invalid_format(&quot;bad magic bytes&quot;)
CookbookError::model_not_found(&quot;/path/to/model.apr&quot;)
CookbookError::feature_not_available(&quot;encryption&quot;)</code></pre>
<h2 id="error-display"><a class="header" href="#error-display">Error Display</a></h2>
<p>All errors implement <code>Display</code>:</p>
<pre><code class="language-rust">let err = CookbookError::invalid_format(&quot;bad header&quot;);
println!(&quot;{}&quot;, err);  // &quot;invalid format: bad header&quot;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feature-flags-1"><a class="header" href="#feature-flags-1">Feature Flags</a></h1>
<p>Configure apr-cookbook capabilities via Cargo features.</p>
<h2 id="available-features"><a class="header" href="#available-features">Available Features</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>default</code></td><td>Core bundling and conversion</td><td>✅</td></tr>
<tr><td><code>encryption</code></td><td>AES-256-GCM encryption</td><td>❌</td></tr>
<tr><td><code>training</code></td><td>entrenar integration</td><td>❌</td></tr>
<tr><td><code>full</code></td><td>All features</td><td>❌</td></tr>
</tbody></table>
</div>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<h3 id="single-feature"><a class="header" href="#single-feature">Single Feature</a></h3>
<pre><code class="language-toml">[dependencies]
apr-cookbook = { version = &quot;0.1&quot;, features = [&quot;encryption&quot;] }
</code></pre>
<h3 id="multiple-features"><a class="header" href="#multiple-features">Multiple Features</a></h3>
<pre><code class="language-toml">[dependencies]
apr-cookbook = { version = &quot;0.1&quot;, features = [&quot;encryption&quot;, &quot;training&quot;] }
</code></pre>
<h3 id="all-features"><a class="header" href="#all-features">All Features</a></h3>
<pre><code class="language-toml">[dependencies]
apr-cookbook = { version = &quot;0.1&quot;, features = [&quot;full&quot;] }
</code></pre>
<h2 id="feature-details"><a class="header" href="#feature-details">Feature Details</a></h2>
<h3 id="encryption"><a class="header" href="#encryption"><code>encryption</code></a></h3>
<p>Enables model encryption with AES-256-GCM:</p>
<pre><code class="language-rust">#[cfg(feature = &quot;encryption&quot;)]
use aprender::format::{save_encrypted, load_encrypted};</code></pre>
<p>Adds dependencies:</p>
<ul>
<li><code>aprender/format-encryption</code></li>
</ul>
<h3 id="training"><a class="header" href="#training"><code>training</code></a></h3>
<p>Enables training integration with entrenar:</p>
<pre><code class="language-rust">#[cfg(feature = &quot;training&quot;)]
use entrenar::Trainer;</code></pre>
<p>Adds dependencies:</p>
<ul>
<li><code>entrenar</code></li>
</ul>
<h2 id="checking-features-at-runtime"><a class="header" href="#checking-features-at-runtime">Checking Features at Runtime</a></h2>
<pre><code class="language-rust">#[cfg(feature = &quot;encryption&quot;)]
fn encrypt_available() -&gt; bool { true }

#[cfg(not(feature = &quot;encryption&quot;))]
fn encrypt_available() -&gt; bool { false }</code></pre>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional Compilation</a></h2>
<pre><code class="language-rust">pub fn save_model(model: &amp;Model, path: &amp;str, encrypt: bool) -&gt; Result&lt;()&gt; {
    if encrypt {
        #[cfg(feature = &quot;encryption&quot;)]
        {
            return save_encrypted(model, path, &quot;password&quot;);
        }

        #[cfg(not(feature = &quot;encryption&quot;))]
        {
            return Err(CookbookError::feature_not_available(&quot;encryption&quot;));
        }
    }

    save(model, path)
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
